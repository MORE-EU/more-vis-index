//    public QueryResults executeQueryM4(Query query) {
//        long from = query.getFrom();
//        long to = query.getTo();
//        QueryResults queryResults = new QueryResults();
//        ViewPort viewPort = query.getViewPort();
//        long pixelColumnInterval = (to - from) / viewPort.getWidth();
//
//        LOG.info("Normal width : {}", viewPort.getWidth());
//        double queryTime = 0;
//        LOG.debug("Pixel column interval: " + pixelColumnInterval + " ms");
//        List<Integer> measures = Optional.ofNullable(query.getMeasures()).orElse(dataset.getMeasures());
//
//        List<PixelColumn> pixelColumns = new ArrayList<>();
//        for (long i = 0; i < viewPort.getWidth(); i++) {
//            long pixelFrom = from + (i * pixelColumnInterval);
//            long pixelTo = pixelFrom + pixelColumnInterval;
//            PixelColumn pixelColumn = new PixelColumn(pixelFrom, pixelTo, measures, viewPort);
//            pixelColumns.add(pixelColumn);
//        }
////        LOG.debug("Created {} pixel columns: {}", viewPort.getWidth(), pixelColumns.stream().map(PixelColumn::getIntervalString).collect(Collectors.joining(", ")));
//        // Query the interval tree for all spans that overlap the query interval.
//
//        List<TimeSeriesSpan> overlappingSpans = StreamSupport.stream(
//                        Spliterators.spliteratorUnknownSize(intervalTree.overlappers(query), 0), false)
//                // Filter out spans with aggregate interval larger than the pixel column interval.
//                // This way, each of the groups of the resulting spans will overlap at most two pixel columns.
//                .filter(span -> pixelColumnInterval >= 2 * span.getAggregateInterval())
//                .collect(Collectors.toList());
//
//        for (TimeSeriesSpan span : overlappingSpans) {
//            if (span instanceof AggregateTimeSeriesSpan) {
//                Iterator<AggregatedDataPoint> iterator = ((AggregateTimeSeriesSpan) span).iterator(from, to);
//                while (iterator.hasNext()) {
//                    AggregatedDataPoint aggregatedDataPoint = iterator.next();
//                    addAggregatedDataPointToPixelColumns(query, pixelColumns, aggregatedDataPoint, viewPort);
//                }
//            }
//            else if (span instanceof RawTimeSeriesSpan){
//                Iterator<DataPoint> iterator = ((RawTimeSeriesSpan) span).iterator(from, to);
//                while (iterator.hasNext()) {
//                    DataPoint dataPoint = iterator.next();
//                    addDataPointToPixelColumns(query, pixelColumns, dataPoint, viewPort);
//                }
//            }
//            else{
//                throw new IllegalArgumentException("Time Series Span Read Error");
//            }
//        }
//        LOG.debug("Overlapping intervals {}", overlappingSpans.stream().map(span -> "" + span.getAggregateInterval() + " (" +query.percentage(span) + ")").collect(Collectors.joining(", ")));
//        MaxErrorEvaluator maxErrorEvaluator = new MaxErrorEvaluator(measures, viewPort, pixelColumns);
//        List<List<Integer>> pixelColumnErrors = maxErrorEvaluator.computeMaxPixelErrorsPerColumnAndMeasure();
//        List<TimeInterval> missingIntervals = maxErrorEvaluator.getMissingRanges();
//        missingIntervals = DateTimeUtil.groupIntervals(pixelColumnInterval, missingIntervals);
//        LOG.info("Unable to Determine Errors: " + missingIntervals);
//
//        // Find the part of the query interval that is not covered by the spans in the interval tree.
//        Map<Integer, Double> error = new HashMap<>();
//        for (int m : measures) error.put(m, 0.0);
//        int validColumns = 0;
//        for (List<Integer> pixelColumnError : pixelColumnErrors) {
//            if(pixelColumnError == null) continue;
//            int i = 0;
//            validColumns ++;
//            for (int m : measures) {
//                final Double data = error.get(m);
//                final int val =  pixelColumnError.get(i);
//                error.put(m, data + val);
//                i++;
//            }
//        }
//        boolean hasError = true;
//        LOG.debug("Valid columns: {}", validColumns);
//        for (int m : measures) {
//            double measureError = error.get(m) / (viewPort.getHeight() * validColumns);
//            LOG.info("Measure has error: {}", measureError);
//            hasError = measureError > 1 - query.getAccuracy();
//            error.put(m, measureError);
//        }
//        if(hasError) {
//            pixelColumns = new ArrayList<>();
//            for (long i = 0; i < viewPort.getWidth(); i++) {
//                long pixelFrom = from + (i * pixelColumnInterval);
//                long pixelTo = pixelFrom + pixelColumnInterval;
//                PixelColumn pixelColumn = new PixelColumn(pixelFrom, pixelTo, measures, viewPort);
//                pixelColumns.add(pixelColumn);
//            }
//            updateAggFactor();
//            missingIntervals = new ArrayList<>();
//            missingIntervals.add(new TimeRange(from, to));
//            LOG.info("Cached data are above error bound. Fetching {}: ", missingIntervals);
//            query.setQueryMethod(QueryMethod.M4_MULTI);
//            getMissing(from, to, measures, viewPort, missingIntervals, pixelColumns, query, queryResults, aggFactor);
//            measures.forEach(m -> error.put(m, 0.0)); // set max error to 0
//        }
//        else {
//            // Fetch the missing data from the data source.
////          LOG.info("Unable to Determine Errors: " + missingIntervals);
//            getMissing(from, to, measures, viewPort, missingIntervals, pixelColumns, query, queryResults, aggFactor);
//            // Recalculate error
//            maxErrorEvaluator = new MaxErrorEvaluator(measures, viewPort, pixelColumns);
//            pixelColumnErrors = maxErrorEvaluator.computeMaxPixelErrorsPerColumnAndMeasure();
//            for (int m : measures) error.put(m, 0.0);
//            for (List<Integer> pixelColumnError : pixelColumnErrors) {
//                if(pixelColumnError == null) continue;
//                int i = 0;
//                for (int m : measures) {
//                    final Double data = error.get(m);
//                    final int val = pixelColumnError.get(i);
//                    error.put(m, data + val);
//                    i++;
//                }
//            }
//            for (int m : measures) {
//                double measureError = error.get(m) / (viewPort.getHeight() * viewPort.getWidth());
//                error.put(m, measureError);
//            }
//        }
//
//        Map<Integer, List<UnivariateDataPoint>> resultData = new HashMap<>();
//        for (int measure : measures) {
//            List<UnivariateDataPoint> dataPoints = new ArrayList<>();
//            for (PixelColumn pixelColumn : pixelColumns) {
//                Stats pixelColumnStats = pixelColumn.getStats();
//                if (pixelColumnStats.getCount() == 0) {
//                    continue;
//                }
//                // filter
//                if(true) {
//                    dataPoints.add(new UnivariateDataPoint(pixelColumnStats.getFirstTimestamp(measure), pixelColumnStats.getFirstValue(measure)));
//                    dataPoints.add(new UnivariateDataPoint(pixelColumnStats.getMinTimestamp(measure), pixelColumnStats.getMinValue(measure)));
//                    dataPoints.add(new UnivariateDataPoint(pixelColumnStats.getMaxTimestamp(measure), pixelColumnStats.getMaxValue(measure)));
//                    dataPoints.add(new UnivariateDataPoint(pixelColumnStats.getLastTimestamp(measure), pixelColumnStats.getLastValue(measure)));
//                }
//            }
//            resultData.put(measure, dataPoints);
//        }
//        resultData.forEach((k, v) -> v.sort(Comparator.comparingLong(UnivariateDataPoint::getTimestamp)));
//        queryResults.setData(resultData);
//        queryResults.setError(error);
//        queryResults.setFlag(hasError);
//        queryResults.setQueryTime(queryTime);
//        queryResults.setAggFactor(aggFactor);
//        return queryResults;
//    }